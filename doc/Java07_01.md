# Chapter07_OOP_02_polymorphism

---

- 제어자(modifier)
    - 제어자란?
        
        → 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
        
        ▪️접근 제어자 : public, protected, default, private
        
        ▪️그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
        
        → 접근 제어자는 한 번에 네가지 중 하나만 선택해서 사용할 수 있다.
        
    
    - static - 클래스의, 공통적인
        
        → 클래스 변수(static 맴버변수)는 하나의 변수를 모든 인스턴스가 공유한다.
        
        → static이 붙은 맴버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.
        
    - final - 마지막의, 변경될 수 없는
        
        → 🍎변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용하면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.
        
        → (생성자를 이용한 final 맴버 변수 초기화(캡슐화))[]
        
    - abstract - 추상의, 미완성의
        
        → 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
        
        → 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 “미완성 설계도”이므로 인스턴스를 생성할 수 없다.
        
    - 접근 제어자 - private, default, protected, public
        
        → 맴버 또는 클래스에 사용되어, 해당하는 맴버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
        
        ▪️접근 제어자 사용 이유
        
        → 외부로부터 데이터를 보호하기 위해 사용
        
        → 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
        
        🍎생성자의 접근 제어자
        
        → 생성자의 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.
        
        → 생성자의 접근 제어자를 private로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다. 이를 활용하면 캡슐화를 한 층 더할 수 있다.
        
        → 🍏 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public method를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.
        
    - 제어자의 조합
        1. 메서드에 static과 abstract를 함께 사용할 수 없다.
        2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
        3. abstract메서드의 접근 제어자가 private일 수 없다.
        4. 메서드에 private와 final을 같이 사용할 필요는 없다.

---

- 다형성(polymorphism)
    
    → 여러 가지 형태를 가질 수 있는 능력을 의미한다.
    
    → 같은 타입의 인스턴스여도 참조변수의 타입에 따라 사용할 수 있는 맴버의 개수가 달라진다.
    
    ```java
    // TV == parent, OLEDTv == child
    TV t = new OLEDTv();
    OLEDTv oledtv = new OLEDTv();
    ```
    
    → 조상 타입의 참조변수로 자손 타입의 인스턴스를 참조할 수 있다.
    
    🍎 부모는 자식을 담을 수 있지만, 자식은 부모를 담을 수 없다.
    
    → 참조 변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다. 따라서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요
    
    **🍎instanceOf** 연산자를 통해 확인할 수 있다.
    
    → 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
    
    - 참조변수와 인스턴스의 연결
        
        → 인스턴스 변수를 자손 클래스에 중복으로 정의 했을 때, 맴버 변수의 경우 참조변수의 타입에 의존한다.
        

---

- 추상클래스(abstract class)
    
    → 미완성 메서드를 부모 객체가 갖고 있으며 abstract 제어자를 갖고 있다.
    
    → 추상 클래스로 인스턴스는 생성할 수 없고 상속을 통해서 자손 클래스에 완성될 수 있다.
    

---

- 인터페이스(interface)
    
    → 일종의 추상 클래스이다.
    
    → 다중 상속이 가능하다.
    
    ▪️작성 방법
    
    → 모든 맴버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
    
    → 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
    
    🍎 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.
    
    - Interface 장점
        1. 개발 시간을 단축시킬 수 있다.
        2. 표준화가 가능하다.
        3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
        4. 독립적인 프로그래밍이 가능하다. 
    - Default Method
        
        →  추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
        

---

- 내부 클래스(InnerClass)
    
    → 내부 클래스에서 외부 클래스의 맴버들을 쉽게 접근할 수 있다.
    
    → 코드의 복잡성을 줄일 수 있다.(캡슐화)
    
- 익명 클래스
    
    → 내부 클래스와 달리 이름이 없다. 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.
    

---